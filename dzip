#!/usr/bin/env python
import hashlib
import os
import stat
import sys
import time
from subprocess import call
from zipfile import ZIP_DEFLATED, ZipFile, ZipInfo


def sha256sum(filepath):
    hasher = hashlib.sha256()
    with open(filepath, "rb") as f:
        for block in iter(lambda: f.read(4096), b""):
            hasher.update(block)
    return hasher.hexdigest()


def make_zipfile(
    base_name,
    root_dir=None,
    base_dir=None,
    timestamp=1609477200,  # (2021, 1, 1, 0, 0, 0)
):
    zipfile_path = os.path.abspath(base_name)
    if not root_dir:
        root_dir = os.getcwd()
    if not base_dir:
        base_dir = os.getcwd()
    year, month, day, hour, minute, second, _, _, _ = time.localtime(timestamp)
    date_time = (year, month, day, hour, minute, second)
    cwd = os.getcwd()
    os.chdir(root_dir)
    paths = [base_dir + "/"]
    for root, directories, files in os.walk(base_dir):
        for file in files:
            paths.append(os.path.join(root, file))
        for directory in directories:
            dirpath = os.path.join(root, directory)
            if os.path.islink(dirpath):
                paths.append(dirpath)
            else:
                paths.append(dirpath + "/")
    with ZipFile(zipfile_path, "w", ZIP_DEFLATED) as zf:
        for path in sorted(paths):
            zinfo = ZipInfo(path)
            zinfo.date_time = date_time
            if path.endswith("/"):
                zinfo.external_attr = (0o755 | stat.S_IFDIR) << 16
                zf.writestr(zinfo, "")
            elif os.path.islink(path):
                zinfo.filename = path  # To strip trailing "/" from dirs
                zinfo.create_system = 3
                zinfo.external_attr = (0o755 | stat.S_IFLNK) << 16
                zf.writestr(zinfo, os.readlink(path))
            else:
                if os.access(path, os.X_OK):
                    zinfo.external_attr = (0o755 | stat.S_IFREG) << 16
                else:
                    zinfo.external_attr = (0o644 | stat.S_IFREG) << 16
                with open(path, "rb") as f:
                    zf.writestr(zinfo, f.read())
    os.chdir(cwd)


def _set_timestamp(path, timestamp):
    if os.path.islink(path) and hasattr(os, "symlink"):
        try:
            os.utime(path, (timestamp, timestamp), follow_symlinks=False)
        except (NotImplementedError, TypeError):  # Windows, Python 2
            year, month, day, hour, minute, _, _, _, _ = time.localtime(
                timestamp
            )
            try:
                call(
                    [
                        "touch",
                        "-h",  # --no-dereference; change time of link itself
                        "-t",
                        "{}{}{}{}{}".format(
                            str(year).zfill(2),
                            str(month).zfill(2),
                            str(day).zfill(2),
                            str(hour).zfill(2),
                            str(minute).zfill(2),
                        ),
                        path,
                    ]
                )
            except:
                pass
    try:
        os.utime(path, (timestamp, timestamp))
    except OSError:
        pass


def extract_zipfile(filename, extract_dir):
    try:
        os.makedirs(extract_dir)
    except OSError:
        pass
    with ZipFile(filename) as zf:
        # Iterate through the files-list backwards so that files that
        # are deeper in the directory hierarchy are extracted first.
        # This facilitates setting the timestamps for higher-level
        # directories *after* the dirs/files within them have been
        # extracted (and thereby prevents them from being overridden)
        for member in reversed(zf.infolist()):
            extracted = zf.extract(member, extract_dir)
            attr = member.external_attr >> 16
            if attr:
                if stat.S_ISLNK(attr) and hasattr(os, "symlink"):
                    os.remove(extracted)
                    os.symlink(zf.open(member).read(), extracted)
                else:
                    os.chmod(extracted, attr)
            #sys.exit(1)
            date_time = member.date_time
            if date_time:
                timestamp = time.mktime(date_time + (0, 0, -1))
                _set_timestamp(extracted, timestamp)


if __name__ == "__main__":
    if sys.argv[1] == "make":
        make_zipfile(sys.argv[2], sys.argv[3], sys.argv[4])
        print("{}  {}".format(sha256sum(sys.argv[2]), sys.argv[2]))
    elif sys.argv[1] == "extract":
        extract_zipfile(sys.argv[2], sys.argv[3])
    else:
        sys.exit("Unknown command")
